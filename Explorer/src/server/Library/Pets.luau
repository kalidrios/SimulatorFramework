--[[⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠘⢿⣿⣿⣿⣷⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣷⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⡇⠀⠀⢀⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⡇⠀⠀⢸⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣧⠀⠀⠘⣿⣿⣿⣷⣤⣀⣀⠀⠀⣀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⡄⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣷⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⡆⠀⠀⠀⠈⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠿⠀⠀⠀⠀⠀⠀⠈⠉⠛⠻⠿⠿⠿⠟⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

	Velvet Groups rbx.lua Framework [2025] - [2025]
	Written by kalidrios - 1037898275229020250
	Developed with a VScode and Rojo.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Pets 
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


local Pets = {}

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Signal = require(Library.Signal)
local Shared = require(Library.Shared)
local Directory = require(Library.Directory)
local Saving = require(ServerLibrary.Saving)
local Functions = require(Library.Functions)
local Settings = require(ServerLibrary.Settings)
local Network = require(ServerLibrary.Network)
local petsModule = require(Modules.Pets)

local IsHardcore = Shared.IsHardcore
local RNG = Random.new()

function Pets.Track(...)
	Signal.Fire("Track Pet", ...)
end

function Pets.Create(player, id, data, checkStorage, disableRarityStats, disableTracking, disableEquip, noTrack) --(player, id, data, applyMaxStorage, d, disableRarityStats, disableTracking, disableEquip, notTrack)
	--warn("PET CREATED PATH:  ", debug.traceback())

	local save = Saving.Get(player)
	if not save then
		return
	end

	local dir = Directory.Pets[id]
	if not dir then
		warn("id", id, "Doesnt exist!")
		return
	end

	local pets = save.Pets
	if save.MaxSlots <= #pets and not checkStorage then
		warn("Max storage", save.MaxSlots, "<=",#pets)
		return
	end

	local GeneratedTimeUID = Pets.GenerateTimeUID(player)
	if not GeneratedTimeUID then
		warn("Failed to generate time UID")
		return
	end

	local newUID = data and data.uid or "id" .. Functions.GenerateUID()

	local strengthMin = dir.strengthMin or 0
	local strengthMax = dir.strengthMax or 0

	local petData = {
		id = id, 
		uid = newUID, 
		idt = GeneratedTimeUID, 
		s = math.round(RNG:NextNumber(strengthMin, strengthMax)), 
		nk = Pets.GenerateNickname(),
		l = false,
		hc = false,
		["h"] = {
			["l"] = {},
			["n"] = 0
		}
	}

	-- JELLY CHANCES
	if dir.jelly then
		if id == "2123" or id == "2124" or id == "2188" or id == "2192" then
			local rep = Functions.Lottery({{ 
				1, --[[Coin]] 50 --%
			},{
				2, --[[Diamonds]] 20 --%
			},{
				3, --[[Chest]] 15 --%
			},{
				4, --[[LuckyBlock]] 10 --%
			},{
				5, --[[Maskot]] 5 --%
			}})

			if rep then
				petData.rep = {rep}
			end
		elseif id == "3016" or id == "3031" then
			local rep = Functions.Lottery({{ 
				1, --[[Coin]] 50 --%
			},{
				2, --[[Diamonds]] 20 --%
			},{
				3, --[[Chest]] 15 --%
			},{
				4, --[[LuckyBlock]] 10 --%
			},{
				5, --[[Maskot]] 4 --%
			},{
				6, --[[Kalidrios]] 1 --%
			}})

			if rep then
				petData.rep = {rep}
			end
		end
	end

	if dir.huge or dir.titanic then
		if not game:GetService("RunService"):IsStudio() then
			petData.l = true
		end	
	end

	save.InventoryNotifications = save.InventoryNotifications + 1

	if data and not dir["isGift"] then
		for v7, v8 in pairs(data) do
			if v7 ~= "g" and v7 ~= "r" or v8 then
				petData[v7] = v8
			end
		end
	end

	if dir.colorVariants then -- idk
		local colorVariants = dir.colorVariants
		local drops = {}
		for i, v in pairs(colorVariants) do
			table.insert(drops, {i, v.Weight})
		end
		local cv = Functions.Lottery(drops)
		if cv then
			petData.cv = cv
		end
	end
	
	local vertexColorGenerator = dir.vertexColorGenerator
	if vertexColorGenerator then
		local randomColor = vertexColorGenerator(RNG)
		local vc = randomColor
		if type(randomColor)~="table" then
			if type(randomColor)=="vector" then
				vc = {randomColor.X,randomColor.Y,randomColor.Z}
			end
		end
		petData.vc = vc
	end

	if (not petData.powers) and not dir["isGift"] then
		if dir.titanic then
			petData.powers = Pets.RollPowers("Titanic")		
		elseif dir.huge then
			if not dir.disableBestFriend then
				petData.powers = Pets.RollPowers("Huge")
			end	
		elseif dir.companionEnchantLevel then
			petData.powers = Pets.RollPowers("Exclusive", nil, dir.companionEnchantLevel)
		elseif dir.rarity == "Mythical" or dir.rarity == "Secret" then
			petData.powers = Pets.RollPowers("Rare")
		elseif dir.rarity == "Legendary" and not dir.isPremium then
			petData.powers = Pets.RollPowers()
		end
	end

	if petData.s and petData.s < 0 and not dir["isGift"] then 
		petData.s = 1 
	end

	if not (data and data.s) then 
		if not disableRarityStats and not dir["isGift"] then
			if petData.g then
				petData.s = petData.s * Shared.PetTypeMult.Golden
			elseif petData.r then
				petData.s = petData.s * Shared.PetTypeMult.Rainbow
			elseif petData.dm then
				petData.s = petData.s * Shared.PetTypeMult["Dark Matter"]
			end
			if petData.sh then
				petData.s = petData.s * Shared.PetTypeMult.Shiny
			end
		end
	end	

	if not petData.s then
		petData.s = 1
	end

	pets[#pets+1] = petData

	Signal.Fire("Pet Added", player, newUID)
	coroutine.wrap(function() 
		Network.FireAll("Pet Added", player, petData) 
	end)()
	if not noTrack and not dir["isGift"] then
		Pets.Track(player, id, newUID)
	end

	if not disableEquip and not dir["isGift"] then
		Pets.Equip(tostring(newUID))
	end	

	petsModule.AddOwner(player.UserId, nil, petData)

	return newUID, petData
end

local allPets = {}
function Pets.Get(petUid)
	if not petUid then
		return
	end

	local petData = allPets[petUid]
	if petData then
		local owner = petData[1]
		local save = Saving.Get(owner, false)

		if save then
			local petDat = save.Pets[petData[2]]

			if petDat and petDat.uid == petUid then
				return petDat, owner
			end
		end
	end

	for i, plyr in ipairs(game.Players:GetPlayers()) do
		local save = Saving.Get(plyr, false)

		if save then
			for x, z in ipairs(save.Pets) do
				if z.uid == petUid then
					allPets[petUid] = { plyr, x }
					return z, plyr
				end
			end
		end
	end

	allPets[petUid] = nil
end

function Pets.Equip(uid)
	local petData, plyr = Pets.Get(uid)

	local save = Saving.Get(plyr)
	if not petData or not plyr or not save then
		warn("Failed to equip")
		return
	end

	local PetsEquipped = IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped  
	for i, v in pairs(PetsEquipped) do
		if i == petData.uid then
			return
		end
	end 

	local plyrMaxEquipped = save.InfPetsEnabled and #save.Pets or Shared.GetMaxEquippedSlots(save)  
	if plyrMaxEquipped <= Functions.DictionaryLength(PetsEquipped) then
		return false, "Can't equip any more pets! (Max " .. plyrMaxEquipped .. "/" .. plyrMaxEquipped .. " pets)"
	end

	PetsEquipped[tostring(uid)] = petData

	if Functions.DictionaryLength(PetsEquipped) > plyrMaxEquipped then
		PetsEquipped[tostring(uid)] = nil
		return false, "Can't equip any more pets! (Max " .. plyrMaxEquipped .. "/" .. plyrMaxEquipped .. " pets)"
	end

	Network.Fire("Pet Equip Changed", plyr, petData.uid, true)
	Signal.Fire("Pet Equipped", uid, plyr)
	return true
end

function Pets.Unequip(p8)
	local petData, plyr = Pets.Get(p8)

	if not petData then
		return
	end

	local save = Saving.Get(plyr)
	if not save then
		return
	end

	local PetsEquipped = IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped

	PetsEquipped[tostring(petData.uid)] = nil

	Network.Fire("Pet Equip Changed", plyr, petData.uid, false)
	Signal.Fire("Pet Unequipped", p8, plyr)
	return true
end

function Pets.IsEquipped(player, uid)
	local save = Saving.Get(player)
	if not save then return end
	local PetsEquipped = IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped

	for puid, pet in pairs(PetsEquipped) do
		if puid == uid then 
			return true
		end
	end

	return false
end

function Pets.Delete(petUid, ignore)
	local dat, plyr = Pets.Get(petUid)
	local save = Saving.Get(plyr)

	if not dat or not plyr or not save then
		warn("Failed")
		return
	end

	local pets = save.Pets
	if #pets <= 1 and not ignore then
		warn("Trying to delete last pet -- " .. plyr.Name)
		return
	end

	for i, v in ipairs(pets) do
		if v.uid == petUid then
			Pets.Unequip(v.uid)
			table.remove(save.Pets, i)
			Signal.Fire("Pet Deleted", petUid, plyr)
			coroutine.wrap(function()
				Network.FireAll("Pet Removed", plyr, petUid) 
			end)()
			return true, plyr
		end
	end

	warn("Couldn't find pet -- " .. plyr.Name)
end

function Pets.GetEquipped(plyr, is)
	local save = Saving.Get(plyr)
	if not save then
		return
	end

	local returningEquipped = {}

	local PetsEquipped = IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped
	for uid, pet in pairs(PetsEquipped) do
		if is then
			table.insert(returningEquipped, uid)
		else
			table.insert(returningEquipped, pet)
		end
	end

	return returningEquipped
end

function Pets.GenerateTimeUID(player)
	local save = Saving.Get(player)
	if not save then
		return
	end

	local idt = 0
	for _, pet in ipairs(save.Pets) do
		idt = math.max(idt, pet.idt)
	end

	return idt + 1
end

function Pets.GenerateNickname()
	local Nicknames = Shared.Nicknames

	return Nicknames[RNG:NextInteger(1, #Nicknames)]
end

function Pets.RollRandomPower(is, am)
	am = am or 1

	local powersLottery = {}

	for i, v in pairs(Directory.Powers) do
		if v.canDrop and (is and v.isUnique or not is) then
			for y, x in pairs(v.tiers) do
				table.insert(powersLottery, { { i, y }, v.dropWeight / y })
			end
		end
	end

	local lottery = Functions.Lottery(powersLottery)
	return unpack(lottery)
end

function Pets.RollPowers(name, am, val)
	local powers = {}

	local genRandomPowers = function(is)
		local power = nil
		local value = nil

		local attempt = 0
		while (not power) do 
			attempt += 1
			power, value = Pets.RollRandomPower(is, am)

			for i, v in ipairs(powers) do
				if v[1] == power then
					power = nil
				end
			end

			game:GetService("RunService").Heartbeat:Wait()
		end

		table.insert(powers, { power, value })
	end

	if name == "Rare" then
		for i = 1, 3 do
			genRandomPowers(i==1)
		end

		return powers
	end

	if name == "Titanic" then
		table.insert(powers, { "Titanic", 1 })
		genRandomPowers()
		return powers
	end

	if name == "Huge" then
		table.insert(powers, { "Best Friend", 1 })
		genRandomPowers()
		return powers
	end

	if name == "Exclusive" then
		table.insert(powers, { "Companion", val or 1 })
		genRandomPowers()
		return powers
	end

	genRandomPowers()

	if RNG:NextNumber() <= Settings.DoublePowerChance then
		genRandomPowers()
	end

	return powers
end

function Pets.GetNFTPet(player, name, serial)
	local save = Saving.Get(player)
	if not save then
		return
	end

	for _, pet in ipairs(save.Pets) do
		local nftData = pet.nftData

		if nftData and nftData.name == name and nftData.serial == serial then
			return pet.uid, pet
		end
	end
end

game.Players.PlayerRemoving:Connect(function(player)
	for i, pet in pairs(allPets) do
		if not pet or not pet[1] or pet[1] == player then
			allPets[i] = nil
		end
	end
end)

coroutine.wrap(function()
	while wait(600) do
		allPets = {}	
	end
end)()

return Pets