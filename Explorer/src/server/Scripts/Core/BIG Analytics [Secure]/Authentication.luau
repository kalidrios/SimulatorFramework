local Authentication = {}
local Encrypt = require(script.Parent:WaitForChild("Encryption"))

-- ======== AUTHENTICATION SPECIFICATION ========
-- Write requests require a few things.  First, each request must contain the
-- following fields: "TS" (timestamp), "baseURL" and "PBLC" (the public access key).
-- each request requires an 'Authentication' header, which can be built as follows:
-- MAKE_AUTH_STRING(query):
--   assert(query contains TS, baseURL, PBLC)
--   let alph = empty string
--   for key, value in alphabeticalSorted(query):
--     append (key + "=" + value + "&") to alph
--   remove trailing '&' from alph
--   let signingKey = KEY_PUBLIC + KEY_PRIVATE
--   let encrypted = HMAC_SHA256(key=signingKey, message=alph)
--   let finalAuthenticationString = "OAuth " + encrypted
-- 
-- The function Authentication.EncodeAuthenticationString implements
-- the pseudocode listed above.

-- ======== PUBLIC AND PRIVATE WRITE KEYS ========
-- protect these bad boys at all cost.  it's okay if the public key gets out, but
-- if the private key is released, anybody will be able to write data.  there is
-- an entirely different set of keys used for reading, which should never be
-- placed inside of a ROBLOX script for security purposes.  if these keys are released,
-- our data is still protected.  worst case scenario, somebody can write some junk
-- data that we can delete later.  but again, that can only happen if this source
-- code is leaked, and some neferious guy actually knows what to do w/ these keys.
-- If these are discovered, we can easily swap them out for a new set of keys.

Authentication.WRITE_KEY_PUBLIC  = "A713440C-005D-4C98-A8C4-C6639C4F14C6";
Authentication.WRITE_KEY_PRIVATE = "A201362C-52A9-462A-B4AD-92C969E30D6B";

function Authentication.EncodeAuthenticationString(queryParams)
	
	local function reportMissingField(field)
		print("Analaytics.EncodeAuthenticationString: missing field '" .. field .. "'")
		return nil
	end
	

	
	local alph = {}
	for k, v in pairs(queryParams) do
		table.insert(alph, {k, v})
	end
	
	table.sort(alph, function(a, b)
		return a[1] < b[1]
	end)
	
	local sigBase = ""
	for _, tuple in ipairs(alph) do
		sigBase = sigBase .. tuple[1] .. "=" .. tuple[2] .. "&"
	end
	sigBase = sigBase:sub(1, sigBase:len() - 1)
	
	local signingKey = Authentication.WRITE_KEY_PUBLIC .. Authentication.WRITE_KEY_PRIVATE
	local encrypted = Encrypt.hmac(Encrypt.sha256, signingKey, sigBase)
	
	local authString = "OAuth " .. encrypted
	return authString
	
end

return Authentication
