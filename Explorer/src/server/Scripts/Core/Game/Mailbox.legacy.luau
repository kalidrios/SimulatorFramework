--[[⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⢨⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣯⠁⠀⠉⠉⠙⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀ ⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀ ⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⣿⣿⣿⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⣿⣿⣿⠀⠈⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠃⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⢹⣿⣿⡀⠀⠀⠀⠈⠉⠙⠛⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠘⣿⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⣵⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠸⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠄⣩⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⡀⢻⣿⣿⣿⣿⣶⣤⣀⣀⡀⠀⠀⠀⣀⣀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
           By: @pggondim     

	Re-scripted this 07/09-12/23 
				
--]]

--------|     Setting     |--------
local MailCost = 1000
local RequiredGameTime = 30 -- x seconds until you can use mail upon joining the server
local WaitTime = 3
local MinimumDiamonds = 100
local MaxInbox = 10
local MailDelay = 1 -- dramatic delay

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local RunService = _L.RunService
local HttpService = _L.HttpService
local isStudio = RunService:IsStudio()
local Players = game:GetService("Players")

--------|    Variables    |--------
local DB = _L.DataStoreService:GetDataStore("mail:".._L.Settings.StatsVersion.._L.Settings.MailVersion)
local joinOS = nil
local debugTimes = {}

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function GetMail(player)
	local data = nil
	local async = "u"..tostring(player.UserId)

	local s, e = pcall(function()
		data = DB:GetAsync(async)
	end) 

	if not s then
		_L.Print("[bold] HUGE ERROR "..e.." | MAIL [/bold]")
		return nil
	end

	if data == nil then
		local defData = _G.GetDefaultData("mail")
		DB:SetAsync(async, HttpService:JSONEncode(defData))

		return defData
	end

	local decoded = HttpService:JSONDecode(data)

	return decoded
end

function UpdateMail(player, newData)
	local data = GetMail(player)
	local async = "u"..tostring(player.UserId)

	if data == nil then
		_L.Print("[bold] ERROR WITH UPDATING MAIL "..async.."[/bold]")
		return
	end

	local s, e = pcall(function()
		DB:UpdateAsync(async, function(oldData)
			oldData = HttpService:JSONDecode(oldData)

			for i, v in pairs(newData) do
				oldData[i] = v
			end

			return HttpService:JSONEncode(oldData)  
		end)
	end)

	if not s then
		_L.Print("[bold] ERROR WITH UPDATING MAIL "..player.." reason: "..e.."[/bold]")
		return false
	end

	coroutine.wrap(function() -- WILL SORT IF PLAYER IS IN GAME
		-- UPDATE HISTORY
		local save = _L.Saving.Get(player)
		if save then
			table.sort(save.MailLog, function(i, v)
				return i.Timestamp < v.Timestamp
			end)
		end
	end)()

	return true
end

function GenerateUUID() 
	local UID = _L.Functions.GenerateUID()

	return "mail-"..UID
end

_L.Network.Invoked("Get Mail").OnInvoke = function(player)
	local data = GetMail(player)

	if data == nil then
		_L.Print("[bold] MALFORMED MAIL DATA [/bold]")
	end
	
	return data
end

_L.Network.Invoked("Send Mail").OnInvoke = function(player, data)
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	local save = _L.Saving.Get(player)
	if not save then
		return
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local success, target = pcall(function()
		if RunService:IsStudio() then
			if data.Recipient == "Player1" then
				return -1
			end
			if data.Recipient == "Player2" then
				return -2
			end
		end

		return Players:GetUserIdFromNameAsync(data.Recipient)
	end)

	if not target or not success then
		return false, "Player doesnt exist."
	end

	if target == player.UserId and not isStudio then
		return false, "You can't mail yourself silly!"
	end

	local totalCost = data.Diamonds + MailCost
	if save.Diamonds < totalCost then
		return false, "You need ".._L.Functions.Commas(totalCost-save.Diamonds).." more Diamonds!"
	end

	if #save.Pets <= 1 then
		return false, "You need at least 1 pet in your inventory at all times!"
	end

	if data.Diamonds > 0 and data.Diamonds < MinimumDiamonds then
		return false, "The minimum amount of Diamonds you can send is ".._L.Functions.NumberShorten(MinimumDiamonds).."!"
	end

	local targetData = GetMail({UserId = target})
	if #targetData.Inbox >= MaxInbox then
		return false, "Player has no space left in their inbox!"
	end

	local Settings = targetData.Settings
	local OtherSettings = Settings.OtherSettings
	local OnlyHuges = OtherSettings.HugesSetting
	local FriendsOnly = OtherSettings.FriendsOnlySetting
	local Enabled = OtherSettings.EnabledSetting
	local RequiredPets = OtherSettings.RequiredPetSetting
	local Rarities = Settings.Rarities

	if #save.Pets < #data.Pets or save.Diamonds < data.Diamonds then
		return false, "???"
	end

	local pet = nil
	if #data.Pets >= 1 then
		pet = _L.Pets.Get(data.Pets[1]) -- you can only mail 1 pet anyways.
		if not (pet and pet.uid) then
			return false, "PET ERROR"
		end

		local dir = _L.Directory.Pets[pet.id]
		if not dir then
			return false, "PET ERROR"
		end

		local rarity = dir.rarity
		local huge = dir.huge
		local titanic = dir.titanic

		local friends = _G.FriendCache[target]
		if titanic then
			return false, "You cannot mail titanics!"
		end
		
		
		if Enabled then
			if not huge and OnlyHuges then
				return false, "Target is only accepting Huges!"
			end
			if not friends and FriendsOnly then
				return false, "Target is only accepting gifts from Friends!"
			end
		else
			return false, "Target isnt accepting gifts!"
		end

		local RaritySetting = Rarities[rarity]
		if RaritySetting then
			return false, "Target isnt accepting "..rarity.." pets!"
		end

		---------------------------------------------------------------

		_L.Pets.Delete(pet.uid)
	else
		if Enabled and RequiredPets then
			return false, "Target is only accepting pets!"
		end
	end

	if #data.Pets >= 1 and not pet then
		return false, "Something went wrong, everything lost will not be refunded :("
	end

	save.Diamonds = save.Diamonds - totalCost

	local UUID = GenerateUUID()

	table.insert(targetData.Inbox, {
		Sender = player.UserId,
		Message = data.Message,
		Diamonds = data.Diamonds,
		Pets = { pet },
		uuid = UUID,
		Timestamp = workspace:GetServerTimeNow()
	})

	table.insert(save.MailLog, {
		Pets = { pet },
		Receiver = target,
		Timestamp = workspace:GetServerTimeNow(),
		Diamonds = data.Diamonds,
		UUID = UUID,
		Username = target == -1 and "Player1" or target == -2 and "Player2" or game.Players:GetNameFromUserIdAsync(target)
	})

	UpdateMail({UserId = target}, targetData)
	
	_G.ProcessPending(player,false)
	task.wait(MailDelay) -- dramatic delay..
	
	_L.Network.Fire( "Notification", player, "Mail sent! ✅", { color = Color3.fromRGB(105, 255, 168) } )
	_L.Network.Fire("Close Mailbox", player)
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)
	
	_G.ProcessPending(player,true)
	
	return true
end

function ClaimMail()

end

_L.Network.Invoked("Claim Mail").OnInvoke = function(player, data)	
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	local save = _L.Saving.Get(player)
	if not save then
		return
	end

	for _, uuid in ipairs(data) do
		for index, uuidData in ipairs(mailData.Inbox) do
			if uuid == uuidData.uuid then
				table.remove(mailData.Inbox, index)

				if uuidData.Pets[1] then
					_L.Pets.Create(player, uuidData.Pets[1].id, uuidData.Pets[1], nil, true)
				end
				_L.Give.Currency(player, uuidData.Diamonds, "Diamonds")

				table.insert(save.MailLog, {
					Pets = uuidData.Pets,
					Sender = uuidData.Sender,
					Timestamp = workspace:GetServerTimeNow(),
					Diamonds = uuidData.Diamonds,
					UUID = uuidData.uuid,
					Username = game.Players:GetNameFromUserIdAsync(uuidData.Sender)
				})
			end
		end
	end
	
	_G.ProcessPending(player,false)
	task.wait(MailDelay) -- dramatic delay..
	
	UpdateMail(player, mailData)
	_L.Network.Fire("Notification", player, "Mail claimed! ✅", { color = Color3.fromRGB(105, 255, 168) } )
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)
	
	_G.ProcessPending(player,true)
	
	return true
end

_L.Network.Invoked("Claim All Mail").OnInvoke = function(player)
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	for index, uuidData in ipairs(mailData.Inbox) do
		table.remove(mailData.Inbox, index)

		if uuidData.Pets[1] then
			_L.Pets.Create(player, uuidData.Pets[1].id, uuidData.Pets[1], nil, true)
		end
		_L.Give.Currency(player, uuidData.Diamonds, "Diamonds")

		local mailLog = _L.Saving.Get(player).MailLog
		if mailLog then
			table.insert(mailLog, {
				Pets = uuidData.Pets,
				Sender = uuidData.Sender,
				Timestamp = workspace:GetServerTimeNow(),
				Diamonds = uuidData.Diamonds,
				UUID = uuidData.uuid,
				Username = game.Players:GetNameFromUserIdAsync(uuidData.Sender)
			})
		end

	end
	
	_G.ProcessPending(player,false)
	task.wait(MailDelay) -- dramatic delay..

	UpdateMail(player, mailData)
	_L.Network.Fire( "Notification", player, "Mail claimed! ✅", { color = Color3.fromRGB(105, 255, 168) } )
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)
	
	_G.ProcessPending(player,true)
	
	return true
end

_L.Network.Invoked("Reject Mail").OnInvoke = function(player, data)
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	for _, uuid in ipairs(data) do
		for index, uuidData in ipairs(mailData.Inbox) do
			if uuid == uuidData.uuid then
				table.remove(mailData.Inbox, index)
			end
		end
	end
	
	_G.ProcessPending(player,false)
	task.wait(MailDelay) -- dramatic delay..

	UpdateMail(player, mailData)
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)
	
	_G.ProcessPending(player,true)
	
	return true
end

_L.Network.Invoked("Get Mailbox Settings").OnInvoke = function(player)
	local mailData = GetMail(player)
	if not mailData then
		return {}
	end

	return mailData.Settings or {}
end

_L.Network.Invoked("Update Mail Settings").OnInvoke = function(player, data)
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	mailData.Settings = data

	UpdateMail(player, mailData)
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)

	return true
end
 
-- isnt this the same thing as above..
_L.Network.Fired("Set Mailbox Settings"):Connect(function(player, data)
	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	mailData.Settings = data

	UpdateMail(player, mailData)
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)

	return true
end)
--
_L.Signal.Fired("Player Added"):Connect(function(player)
	debugTimes[player] = {
		Time = os.clock(),
		CanMail = false
	}
end)
--[[ Last synced 9/21/2025 04:47                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Às vezes é mais fácil desistir mesmo ]]    --[[                                                                                                  ]]--