--[[⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠘⢿⣿⣿⣿⣷⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣷⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⡇⠀⠀⢀⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⡇⠀⠀⢸⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣧⠀⠀⠘⣿⣿⣿⣷⣤⣀⣀⠀⠀⣀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⡄⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣷⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⡆⠀⠀⠀⠈⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠿⠀⠀⠀⠀⠀⠀⠈⠉⠛⠻⠿⠿⠿⠟⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

	Velvet Groups rbx.lua Framework [2025] - [2025]
	Written by kalidrios - 1037898275229020250
	Developed with a VScode and Rojo.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.InfoOverlay
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local table1 = {};
local ReplicatedStorage = game:GetService("ReplicatedStorage");
local TextService = game:GetService("TextService");
local Players = game:GetService("Players");
local RunService = game:GetService("RunService");
local GuiService = game:GetService("GuiService");
local Library = ReplicatedStorage:WaitForChild("Library");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local m_Functions = require(Library.Functions);
local m_Variables = require(Library.Variables);
local t_InfoOverlay = Assets.UI.FRAMEWORK.InfoOverlay;
local Blocks = t_InfoOverlay:WaitForChild("Blocks");
local GuiInset = game:GetService("GuiService"):GetGuiInset();
local u1 = nil;
local table2 = {};
local table3 = {};
local InfoOverlay = nil;
function table1.Add(p1, ...) -- Anonymous function at line 110
	--[[
		Upvalues:
			[1] = u1
			[2] = table1
			[3] = t_InfoOverlay
			[4] = Blocks
			[5] = table2
			[6] = TextService
			[7] = m_Functions
			[8] = InfoOverlay
			[9] = Players
			[10] = Assets
			[11] = RunService
			[12] = GuiInset
			[13] = m_Variables
			[14] = GuiService
			[15] = table3
	--]]
	if u1 then
		table1.Remove();
	end
	local Clone_ret = t_InfoOverlay:FindFirstChild("Base"):Clone();
	local v1 = 0;
	local str1 = "Down";
	for key1, val1 in ipairs({...}) do
		local u2 = val1[1];
		local Clone_ret3 = Blocks:FindFirstChild(u2):Clone();
		local settings = Clone_ret3:FindFirstChild("settings");
		if settings and settings:FindFirstChild("code") then
			local coroutine_wrap_ret6 = coroutine.wrap(function() -- Line: 131
				--[[
					Upvalues:
						[1] = table2
						[2] = u2
						[3] = settings
						[4] = Clone_ret3
						[5] = val1
				--]]
				local v15 = table2[u2] or require(settings:FindFirstChild("code"));
				v15(Clone_ret3, unpack(val1));
			end);
			coroutine_wrap_ret6();
		end
		Clone_ret3.LayoutOrder = key1 * 100;
		Clone_ret3.Parent = Clone_ret.Frame.Blocks;
		if not settings then continue end
		local Attribute2 = settings:GetAttribute("boundsX");
		local t_X5 = Attribute2.X;
		local t_Y5 = Attribute2.Y;
		local v3 = 0;
		local v4 = 0;
		local v5 = 0;
		for _, child3 in ipairs(Clone_ret3:GetChildren()) do
			if not child3:IsA("GuiObject") or not child3.Visible then continue end
			if child3.ClassName == "TextLabel" or child3.ClassName == "TextButton" then
				if child3.Size.X.Scale == 0 then continue end
				local vec2 = Vector2.new(t_Y5 * child3.Size.X.Scale, 1000);
				local v6 = TextService:GetTextSize(child3.ContentText, child3.TextSize, child3.Font, vec2) + Vector2.new(4, 1);
				v3 = math.max(v6.X, v3);
				v4 = v4 + math.max(v6.Y, Clone_ret3.AbsoluteSize.Y);
				child3.Size = UDim2.new(0, v6.X, 0, v6.Y);
				continue;
			end
			if child3.Size.X.Scale == 0 then continue end
			v5 = v5 + child3.AbsoluteSize.Y;
		end
		local UIListLayout2 = Clone_ret3:FindFirstChildOfClass("UIListLayout");
		if UIListLayout2 and UIListLayout2.FillDirection == Enum.FillDirection.Horizontal then
			v3 = math.max(UIListLayout2.AbsoluteContentSize.X, v3);
		end
		local UIGridLayout = Clone_ret3:FindFirstChildOfClass("UIGridLayout");
		if UIGridLayout then
			v4 = math.max(UIGridLayout.AbsoluteContentSize.Y, v4);
		end
		Clone_ret3.Size = UDim2.new(1, 0, 0, v4 + v5);
		local math_clamp_ret = math.clamp(v3, t_X5, t_Y5);
		v1 = math.max(math_clamp_ret, v1);
	end
	local UIPadding = Clone_ret.Frame.Blocks:FindFirstChildOfClass("UIPadding");
	local UIListLayout = Clone_ret.Frame.Blocks:FindFirstChildOfClass("UIListLayout");
	UIListLayout:ApplyLayout();
	Clone_ret.Size = UDim2.new(0, v1 + UIPadding.PaddingLeft.Offset + UIPadding.PaddingRight.Offset, 0, UIListLayout.AbsoluteContentSize.Y + UIPadding.PaddingTop.Offset + UIPadding.PaddingBottom.Offset);
	Clone_ret.UIScale.Scale = (1 - (1 - math.min(m_Functions.ResolutionScale(), 1)) / 1.5) * 0.9;
	if not InfoOverlay then
		InfoOverlay = Instance.new("ScreenGui");
		InfoOverlay.DisplayOrder = 100;
		InfoOverlay.ZIndexBehavior = Enum.ZIndexBehavior.Global;
		InfoOverlay.ResetOnSpawn = false;
		InfoOverlay.Name = "InfoOverlay";
		InfoOverlay.Parent = Players.LocalPlayer.PlayerGui;
	end
	Clone_ret.Parent = InfoOverlay;
	u1 = Clone_ret;
	local v2 = nil;
	for _, val2 in ipairs({...}) do
		if val2[1] ~= "Rarity" or not val2[2] then continue end
		v2 = val2[2];
		break;
	end
	if v2 == "Mythical" or v2 == "Secret" or v2 == "Exclusive" then
		local UIStroke = Clone_ret.Frame:FindFirstChildOfClass("UIStroke");
		UIStroke.Color = Color3.new(1, 1, 1);
		local Clone_ret2 = Assets.UI.Raritys:FindFirstChild(v2):Clone();
		Clone_ret2.Parent = UIStroke;
		if v2 == "Mythical" then
			Clone_ret.pointer.pointer.ImageColor3 = Color3.fromRGB(255, 218, 32);
		elseif v2 == "Secret" then
			Clone_ret.pointer.pointer.ImageColor3 = Color3.fromRGB(217, 242, 243);
		elseif v2 == "Exclusive" then
			Clone_ret.pointer.pointer.ImageColor3 = Color3.fromRGB(217, 163, 255);
		end
		if v2 == "Secret" then
			local coroutine_wrap_ret5 = coroutine.wrap(function() -- Line: 273
				--[[
					Upvalues:
						[1] = Clone_ret
						[2] = m_Functions
				--]]
				local v16 = false;
				while Clone_ret and Clone_ret.Parent do
					v16 = not v16;
					m_Functions.Tween(Clone_ret.pointer, {ImageColor3 = v16 and Color3.fromRGB(217, 242, 243) or Color3.fromRGB(255, 255, 255)}, {
						1.25,
						"Sine",
						"InOut"
					});
					m_Functions.Tween(Clone_ret.Frame, {BackgroundColor3 = v16 and Color3.fromRGB(217, 242, 243) or Color3.fromRGB(255, 255, 255)}, {
						1.25,
						"Sine",
						"InOut"
					}).Completed:Wait();
				end
			end);
			coroutine_wrap_ret5();
		elseif v2 == "Mythical" then
			local coroutine_wrap_ret4 = coroutine.wrap(function() -- Line: 284
				--[[
					Upvalues:
						[1] = Clone_ret
						[2] = m_Functions
				--]]
				local v17 = false;
				while Clone_ret and Clone_ret.Parent do
					v17 = not v17;
					m_Functions.Tween(Clone_ret.pointer, {ImageColor3 = v17 and Color3.fromRGB(255, 245, 230) or Color3.new(1, 1, 1)}, {
						1.25,
						"Sine",
						"InOut"
					});
					m_Functions.Tween(Clone_ret.Frame, {BackgroundColor3 = v17 and Color3.fromRGB(255, 245, 230) or Color3.new(1, 1, 1)}, {
						1.25,
						"Sine",
						"InOut"
					}).Completed:Wait();
				end
			end);
			coroutine_wrap_ret4();
		end
		local coroutine_wrap_ret3 = coroutine.wrap(function() -- Line: 295
			--[[
				Upvalues:
					[1] = Clone_ret
					[2] = Clone_ret2
					[3] = RunService
			--]]
			while Clone_ret and Clone_ret.Parent do
				Clone_ret2.Rotation = os.clock() * 250;
				RunService.RenderStepped:Wait();
			end
		end);
		coroutine_wrap_ret3();
	end
	local coroutine_wrap_ret = coroutine.wrap(function() -- Line: 352
		--[[
			Upvalues:
				[1] = Players
				[2] = Clone_ret
				[3] = GuiInset
				[4] = m_Variables
				[5] = p1
				[6] = str1
				[7] = RunService
		--]]
		local Mouse = Players.LocalPlayer:GetMouse();
		local t_CurrentCamera = game.Workspace.CurrentCamera;
		while Clone_ret and Clone_ret.Parent do
			local v7 = Mouse.X;
			local v8 = Mouse.Y;
			local t_X = Clone_ret.AbsoluteSize.X;
			local t_Y = Clone_ret.AbsoluteSize.Y;
			local v9 = t_CurrentCamera.ViewportSize.X - GuiInset.X;
			local v10 = t_CurrentCamera.ViewportSize.Y - GuiInset.Y;
			if m_Variables.Console then
				v7 = p1.AbsolutePosition.X + p1.AbsoluteSize.X * 0.5;
				v8 = p1.AbsolutePosition.Y + p1.AbsoluteSize.Y * 0.5;
			end
			if v8 + t_Y + 10 < v10 then
				str1 = "Down";
			elseif v8 - t_Y - 10 > 0 then
				str1 = "Up";
			end
			local v11 = v9 + (-t_X or t_X);
			local v12 = v10 + (str1 == "Down" and -t_Y or t_Y);
			local v13 = v7 + 10;
			local v14 = v8 + (str1 == "Down" and 10 or -10);
			Clone_ret.AnchorPoint = Vector2.new(0, str1 == "Down" and 0 or 1);
			Clone_ret.Position = UDim2.new(0, math.clamp(v13, 0, v11), 0, (math.clamp(v14, 0, v12)));
			RunService.RenderStepped:Wait();
		end
	end);
	coroutine_wrap_ret();
	local coroutine_wrap_ret2 = coroutine.wrap(function() -- Line: 408
		--[[
			Upvalues:
				[1] = Players
				[2] = p1
				[3] = table1
				[4] = Clone_ret
				[5] = m_Variables
				[6] = GuiService
				[7] = RunService
		--]]
		local Mouse2 = Players.LocalPlayer:GetMouse();
		local Attribute = p1:GetAttribute("SurfaceElement");
		if Attribute then
			local Connect_ret = nil;
			Connect_ret = p1.MouseLeave:Connect(function() -- Line: 414
				--[[
					Upvalues:
						[1] = table1
						[2] = Connect_ret
				--]]
				table1.Remove();
				Connect_ret:Disconnect();
			end);
			return;
		end
		while Clone_ret and Clone_ret.Parent do
			local t_X2 = Mouse2.X;
			local t_Y2 = Mouse2.Y;
			local t_X3 = p1.AbsolutePosition.X;
			local t_Y3 = p1.AbsolutePosition.Y;
			local t_X4 = p1.AbsoluteSize.X;
			local t_Y4 = p1.AbsoluteSize.Y;
			if not m_Variables.Console then
				if t_X3 + t_X4 < t_X2 or t_X2 < t_X3 or t_Y3 + t_Y4 < t_Y2 or t_Y2 < t_Y3 then
					table1.Remove();
				end
			elseif GuiService.SelectedObject ~= p1 then
				table1.Remove();
			end
			RunService.RenderStepped:Wait();
		end
	end);
	coroutine_wrap_ret2();
	if m_Variables.Mobile then
		local tick_ret = tick();
		local Connect_ret2 = nil;
		Connect_ret2 = p1.MouseButton1Up:Connect(function() -- Line: 444
			--[[
				Upvalues:
					[1] = Connect_ret2
					[2] = tick_ret
					[3] = table1
			--]]
			Connect_ret2:Disconnect();
			if tick() - tick_ret < 0.5 then
				table1.Remove();
			end
		end);
		table3[#table3 + 1] = Connect_ret2;
	end
end
function table1.Remove() -- Anonymous function at line 455
	--[[
		Upvalues:
			[1] = u1
			[2] = table3
	--]]
	if u1 then
		for _, val4 in ipairs(table3) do
			val4:Disconnect();
		end
		table3 = {};
		u1:Destroy();
		u1 = nil;
	end
end
return table1;
