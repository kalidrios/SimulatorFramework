--[[⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠘⢿⣿⣿⣿⣷⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣷⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⡇⠀⠀⢀⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⡇⠀⠀⢸⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣧⠀⠀⠘⣿⣿⣿⣷⣤⣀⣀⠀⠀⣀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⡄⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣷⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⡆⠀⠀⠀⠈⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠿⠀⠀⠀⠀⠀⠀⠈⠉⠛⠻⠿⠿⠿⠟⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

	Velvet Groups rbx.lua Framework [2025] - [2025]
	Written by kalidrios - 1037898275229020250
	Developed with a VScode and Rojo.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.WorldCmds
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local WorldCmds = {}
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local __THINGS = workspace:WaitForChild("__THINGS")
local __DEBRIS = workspace:WaitForChild("__DEBRIS")
local Library = ReplicatedStorage:WaitForChild("Library")
local Client = Library:WaitForChild("Client")
----
local Shared = require(Library.Shared)
local Variables = require(Library.Variables)
local Directory = require(Library.Directory)
local Audio = require(Library.Audio)
local Signal = require(Library.Signal)
local Functions = require(Library.Functions)
local GUIFX = require(Client.GUIFX)
local Network = require(Client.Network)
local Save = require(Client.Save)
local GUI = require(Client.GUI)
local Gamepasses = require(Client.Gamepasses)
----
local Coins = __THINGS:WaitForChild("Coins")
local Orbs = __THINGS:WaitForChild("Orbs")
local Lootbags = __THINGS:WaitForChild("Lootbags")
----
local IsHardcore = Shared.IsHardcore
local TeleportID = Directory.Gamepasses.Teleport.ID
----
function WorldCmds.Load(world, arg) 
	Variables.LoadingWorld = true
	
	if Shared.IsTradingPlaza then
		world = "Trading Plaza"
	end
	
	if not game:GetService("RunService"):IsStudio() and world == "Trading Plaza" and not Shared.IsTradingPlaza then
		world = "Spawn"
	end
	
	if not Directory.Worlds[tostring(world)] then
		world = "Spawn"
	end
	
	if world == "Diamond Mine" then
		assert(Save.Get())
		if Signal.Invoke("Get Diamond Mine Collpase Time") then
			world = "Spawn"
		end
	end
	
	local Loading = GUIFX.Loading(tostring(world))
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
	
	HumanoidRootPart.Anchored = true
	
	local save = Save.Get()
	assert(save)
	
	local RequestWorld = Network.Invoke("Request World", world)
	if not RequestWorld then
		HumanoidRootPart.Anchored = false
		Loading()
		return false
	end
	
	if not IsHardcore then
		save.World = world
	else
		save.Hardcore.World = world
	end
	
	while not Players.LocalPlayer.PlayerGui:FindFirstChild("__MAP") do
		RunService.RenderStepped:Wait()
	end
	
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	local HumanoidRootPart2 = Character:WaitForChild("HumanoidRootPart")
	HumanoidRootPart2.Anchored = true
	
	if game.Workspace:FindFirstChild("__MAP") then
		game.Workspace:FindFirstChild("__MAP"):Destroy()
	end
	
	Coins:ClearAllChildren()
	Orbs:ClearAllChildren()
	Lootbags:ClearAllChildren()
	
	local PlayerGui = Players.LocalPlayer.PlayerGui
	local __MAP = PlayerGui:FindFirstChild("__MAP")
	
	while not __MAP do
		wait(0.1)
		PlayerGui:FindFirstChild("__MAP")
	end
	
	local MAP = __MAP:WaitForChild("MAP", 9999999)
	local LIGHTING = IsHardcore and __MAP:FindFirstChild("HARDCORE_LIGHTING") or __MAP:WaitForChild("LIGHTING", 9999999)
	local Settings = LIGHTING:WaitForChild("Settings")
	
	local Dir = Directory.Worlds[world]
	
	for i, child in ipairs(game.Lighting:GetChildren()) do
		if child.Name == "EggBlur" then continue end
		child:Destroy()
	end
	
	MAP:FindFirstChild("Spawns"):Destroy()
	
	for i, child in ipairs(LIGHTING:GetChildren()) do
		if child.ClassName == "Configuration" then continue end
		local Clone_ret = child:Clone()
		Clone_ret.Name = "__WORLDFX"
		Clone_ret.Parent = game.Lighting
	end
	
	for i, child in ipairs(Settings:GetChildren()) do
		game.Lighting[child.Name] = child.Value
	end
	
	local __MAPDEBRIS = __DEBRIS:FindFirstChild("__MAPDEBRIS")
	
	if not __MAPDEBRIS then
		__MAPDEBRIS = Instance.new("Folder")
		__MAPDEBRIS.Name = "__MAPDEBRIS"
		__MAPDEBRIS.Parent = __DEBRIS
	else
		__MAPDEBRIS:ClearAllChildren()
	end
	
	if MAP:FindFirstChild("Debris") then
		MAP.Debris.Parent = __MAPDEBRIS
	end
	
	MAP.Name = "__MAP"
	MAP.Parent = game.Workspace
	
	for i, descendant in ipairs(MAP:WaitForChild("Audio", 9999999):GetDescendants()) do
		if descendant.ClassName ~= "Sound" then continue end
		local string_match_ret = string.match(descendant.SoundId, "%d+")
		local playingAudio = Audio.Play(string_match_ret, descendant.Parent, descendant.Pitch, descendant.Volume, descendant.MaxDistance, descendant.SoundGroup, descendant.Looped)
		playingAudio.RollOffMinDistance = descendant.RollOffMinDistance
	end
	
	__MAP:Destroy()
	
	game.Workspace.Gravity = Dir.gravity or 196.2
	
	local Children = MAP:FindFirstChild("PlayerSpawns"):GetChildren()
	
	local CFrame = Children[math.random(1, #Children)].CFrame
	local PositionData = save.PositionData
	
	local deb = false
	
	local function from_array(array)
		return CFrame.new(array[1], array[2], array[3], array[4], array[5], array[6], array[7], array[8], array[9], array[10], array[11], array[12])
	end
	
	if arg and PositionData and PositionData.PlayerCFrame then
		deb = true
		local t_PlayerCFrame = PositionData.PlayerCFrame
		CFrame = CFrame.new(t_PlayerCFrame[1], t_PlayerCFrame[2], t_PlayerCFrame[3], t_PlayerCFrame[4], t_PlayerCFrame[5], t_PlayerCFrame[6], t_PlayerCFrame[7], t_PlayerCFrame[8], t_PlayerCFrame[9], t_PlayerCFrame[10], t_PlayerCFrame[11], t_PlayerCFrame[12])
	end
	
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	local HumanoidRootPart3 = Character:WaitForChild("HumanoidRootPart")
	local Humanoid = Character:WaitForChild("Humanoid")
	
	Character:SetPrimaryPartCFrame(CFrame + Vector3.new(0, 8, 0))
	HumanoidRootPart3.AssemblyLinearVelocity = Vector3.new()
	HumanoidRootPart3.AssemblyAngularVelocity = Vector3.new()
	HumanoidRootPart3.Anchored = false
	Humanoid.PlatformStand = false
	
	if deb and PositionData.CameraCFrame and PositionData.CameraFocus then
		local CameraCFrame = PositionData.CameraCFrame
		local cf = CFrame.new(CameraCFrame[1], CameraCFrame[2], CameraCFrame[3], CameraCFrame[4], CameraCFrame[5], CameraCFrame[6], CameraCFrame[7], CameraCFrame[8], CameraCFrame[9], CameraCFrame[10], CameraCFrame[11], CameraCFrame[12])
		local CameraFocus = PositionData.CameraFocus
		local cf2 = CFrame.new(CameraFocus[1], CameraFocus[2], CameraFocus[3], CameraFocus[4], CameraFocus[5], CameraFocus[6], CameraFocus[7], CameraFocus[8], CameraFocus[9], CameraFocus[10], CameraFocus[11], CameraFocus[12])
		
		workspace.CurrentCamera.CFrame = cf
		
		local Magnitude = (cf.Position - cf2.Position).Magnitude
		local CameraMinZoomDistance = Players.LocalPlayer.CameraMinZoomDistance
		local CameraMaxZoomDistance = Players.LocalPlayer.CameraMaxZoomDistance
		local math_clamp_ret = math.clamp(Magnitude, CameraMinZoomDistance, CameraMaxZoomDistance)
		
		Players.LocalPlayer.CameraMinZoomDistance = math_clamp_ret
		Players.LocalPlayer.CameraMaxZoomDistance = math_clamp_ret
		
		task.delay(0.1, function() 
			Players.LocalPlayer.CameraMinZoomDistance = CameraMinZoomDistance
			Players.LocalPlayer.CameraMaxZoomDistance = CameraMaxZoomDistance
		end)
	end
	
	Signal.Fire("World Changed", world, MAP)
	
	task.wait(0.5)
	
	task.spawn(function() 
		task.wait(1.5)
		if Variables.LoadingWorld then return end
		Audio.Play("rbxassetid://7358008634", script, 1, 0.3)
		local WorldLoaded = GUI.WorldLoaded
		local WorldTitle = WorldLoaded.WorldTitle
		WorldTitle.Text = "~" .. Dir.display .. "~"
		WorldTitle.TextTransparency = 1
		WorldTitle.TextStrokeTransparency = 1
		WorldTitle.Position = UDim2.new(0.5, 0, 0.025, 0)
		WorldLoaded.Gui.Enabled = true
		
		Functions.Tween(WorldTitle:FindFirstChildOfClass("UIStroke"), {Transparency = 0}, {
			0.4,
			"Sine",
			"Out"
		})
		
		Functions.Tween(WorldTitle, {
			TextTransparency = 0,
			TextStrokeTransparency = 0,
			Position = UDim2.new(0.5, 0, 0.05, 0)
		}, {
			0.4,
			"Sine",
			"Out"
		}).Completed:Wait()
		
		task.wait(2)
		
		Functions.Tween(WorldTitle:FindFirstChildOfClass("UIStroke"), {Transparency = 1}, {
			0.4,
			"Sine",
			"In"
		})
		
		Functions.Tween(WorldTitle, {
			TextTransparency = 1,
			TextStrokeTransparency = 1,
			Position = UDim2.new(0.5, 0, 0.025, 0)
		}, {
			0.4,
			"Sine",
			"In"
		}).Completed:Wait()
		
		WorldLoaded.Gui.Enabled = false
	end)
	
	Loading()
	Variables.LoadingWorld = false
	return true
end

function WorldCmds.HasArea(area)
	assert(typeof(area) == "string")
	assert(Directory.Areas[area])
	
	local save = Save.Get()
	if not save then
		return false
	end
	
	assert(save)
	
	if area == "VIP" then
		return Functions.SearchArray(save.AreasUnlocked, area) or Functions.SearchArray(save.Hardcore.AreasUnlocked, area)
	end
	
	return Functions.SearchArray(IsHardcore and save.Hardcore.AreasUnlocked or save.AreasUnlocked, area)
end

function WorldCmds.HasAccess(world) 
	assert(typeof(world) == "string")
	
	local dir = Directory.Worlds[world]
	assert(dir)
	
	local requiredArea = dir.requiredArea
	
	if requiredArea and not WorldCmds.HasArea(requiredArea) then
		return false
	end
	
	return true
end

function WorldCmds.Get(player) 
	local save = Save.Get(player)
	if not save then
		return nil
	end
	
	assert(save)
	
	return IsHardcore and save.Hardcore.World or save.World
end

function WorldCmds.GetMap() 
	return game.Workspace:WaitForChild("__MAP", 9999)
end

function WorldCmds.GetDir()
	local dir = WorldCmds.Get()
	assert(dir)
	
	return Directory.Worlds[dir]
end

function WorldCmds.HasLoaded() 
	if Variables.LoadingWorld == nil then
		return false
	end
	
	if Variables.LoadingWorld == true then
		return false
	end
	
	local __MAP = game.Workspace:FindFirstChild("__MAP")
	
	if not __MAP then
		return false
	end
	
	if not __MAP:FindFirstChild("PlayerSpawns") then
		return false
	end
	return true
end

function WorldCmds.HasTeleport(area) 
	assert(typeof(area) == "string")
	
	local dir = Directory.Areas[area]
	assert(dir)
	
	local save = Save.Get()
	if not save then
		return false
	end
	assert(save)
	
	if not WorldCmds.HasAccess(dir.world) then
		return false
	end
	
	if not WorldCmds.HasArea(area) then
		return false
	end
	
	if Gamepasses.Owns(TeleportID) then
		return true
	end
	
	if Functions.SearchArray(IsHardcore and save.Hardcore.TeleportsUnlocked or save.TeleportsUnlocked, area) then
		return true
	end
	
	return false
end

function WorldCmds.CanDoAction() 
	
	return not Variables.LoadingWorld and not Variables.UsingCannon and (Variables.OpeningEgg <= 0 and not Variables.Trading and not Variables.UsingMachine and WorldCmds.HasLoaded() or false)
end

function WorldCmds.GetAllEggs() 
	local allEggs = {}
	
	local Map = WorldCmds.GetMap()
	if Map then
		local Eggs = Map:FindFirstChild("Eggs")
		
		if Eggs then
			for i, child in ipairs(Eggs:GetChildren()) do
				if not child:FindFirstChild("Eggs") then continue end
				
				for i, child2 in ipairs(child.Eggs:GetChildren()) do
					if not child2:GetAttribute("ID") then continue end
					table.insert(allEggs, child2)
				end
			end
		end
	end
	
	return allEggs
end

function WorldCmds.GetAllGates() 
	local allGates = {}
	local Map = WorldCmds.GetMap()
	
	if Map then
		local Gates = Map:FindFirstChild("Gates")
		
		if Gates then
			for i, child in ipairs(Gates:GetChildren()) do
				table.insert(allGates, child)
			end
		end
	end
	return allGates
end

Network.Invoked("Has Loaded").OnInvoke = function()
    return WorldCmds.HasLoaded()
end

return WorldCmds
